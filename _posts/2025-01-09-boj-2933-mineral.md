---
title: "BOJ 2933 — 미네랄 (C++ 풀이)"
description: "시뮬레이션과 BFS를 결합한 미네랄 파괴 문제. 클러스터 분리 감지와 중력 낙하 처리가 핵심이다."
date: 2025-01-09
categories: [Algorithm]
tags: [Algorithm, BFS, Simulation]
---

## 문제

[BOJ 2933 - 미네랄](https://www.acmicpc.net/problem/2933)

R×C 동굴에 미네랄이 있고, 좌우에서 번갈아 막대를 던져 미네랄을 파괴한다. 미네랄이 파괴되면 연결되지 않은 클러스터가 중력에 의해 떨어질 수 있다.

## 핵심 아이디어

1. 막대를 던져 처음 만나는 미네랄을 파괴한다 (좌→우, 우→좌 교대).
2. 파괴 후 상하좌우 인접한 미네랄들을 BFS로 클러스터링한다.
3. 바닥에 닿지 않는 클러스터가 있으면 낙하시킨다.
4. 낙하 거리는 클러스터 하단 각 열에서 바닥 또는 다른 미네랄까지의 최소 거리로 결정한다.

## 풀이

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

struct Vector2 { int x, y; };

struct Compare {
    bool operator()(const Vector2& lhs, const Vector2& rhs) {
        return lhs.y < rhs.y;
    }
};

int r, c, n, h;
char map[101][101];
bool is_right;

Vector2 direction[4] = {{1,0},{0,1},{-1,0},{0,-1}};

void find_cluster(Vector2 pos, int (*group)[101], int group_number);
int calculate_height(Vector2 pos, int (*group)[101]);

Vector2 throw_stick(int h, bool is_right) {
    for (int i = 0; i < c; i++) {
        int x = is_right ? c - i - 1 : i;
        if (map[h][x] == 'x') return {x, h};
    }
    return {-1, -1};
}

void broke_mineral(Vector2 pos) {
    int group[101][101] = {0,};
    int group_size = 1;

    map[pos.y][pos.x] = '.';

    for (int i = 0; i < 4; i++) {
        Vector2 next = {pos.x + direction[i].x, pos.y + direction[i].y};
        if (next.x < 0 || next.x >= c || next.y < 0 || next.y >= r) continue;
        if (map[next.y][next.x] == '.') continue;
        if (group[next.y][next.x] != 0) continue;

        find_cluster(next, group, group_size++);
    }
}

void find_cluster(Vector2 pos, int (*group)[101], int group_number) {
    queue<Vector2> q;
    priority_queue<Vector2, vector<Vector2>, Compare> pq;

    q.push(pos);

    while (!q.empty()) {
        Vector2 cur = q.front(); q.pop();
        if (group[cur.y][cur.x] != 0) continue;
        if (map[cur.y][cur.x] == '.') continue;

        group[cur.y][cur.x] = group_number;
        pq.push(cur);

        for (int i = 0; i < 4; i++) {
            Vector2 next = {cur.x + direction[i].x, cur.y + direction[i].y};
            if (next.x < 0 || next.x >= c || next.y < 0 || next.y >= r) continue;
            q.push(next);
        }
    }

    // 바닥에 닿지 않는 클러스터 낙하
    if (pq.size() > 0 && pq.top().y != r - 1) {
        int moveY = 101;
        Vector2 lt = {101, 101}, rb = {0, 0};

        while (!pq.empty()) {
            Vector2 cur = pq.top(); pq.pop();
            lt.x = min(cur.x, lt.x); lt.y = min(cur.y, lt.y);
            rb.x = max(cur.x, rb.x); rb.y = max(cur.y, rb.y);

            if (cur.y + 1 < r && map[cur.y + 1][cur.x] == '.') {
                moveY = min(moveY, calculate_height(cur, group));
            }
        }

        for (int y = rb.y; y >= lt.y; y--) {
            for (int x = rb.x; x >= lt.x; x--) {
                if (map[y][x] == '.' || group[y][x] != group_number) continue;
                map[y + moveY][x] = map[y][x];
                map[y][x] = '.';
            }
        }
    }
}

int calculate_height(Vector2 pos, int (*group)[101]) {
    int g = group[pos.y][pos.x];
    int ny = pos.y + 1;

    while ((map[ny][pos.x] == '.' && ny < r) || group[ny][pos.x] == g) {
        ny++;
    }

    return ny - pos.y - 1;
}

int main() {
    cin >> r >> c;
    for (int i = 0; i < r; i++)
        for (int j = 0; j < c; j++)
            cin >> map[i][j];

    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> h;
        Vector2 broken_point = throw_stick(r - h, is_right);
        is_right = !is_right;
        if (broken_point.x == -1 && broken_point.y == -1) continue;
        broke_mineral(broken_point);
    }

    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) cout << map[i][j];
        cout << endl;
    }

    return 0;
}
```

## 주요 포인트

- 클러스터 낙하 시 **아래에서 위로** 처리해야 덮어쓰기 문제가 없다.
- `priority_queue`로 y좌표가 큰(아래쪽) 노드를 먼저 꺼내서 낙하 거리를 정확히 계산한다.
- 높이 입력이 1-indexed이므로 `r - h`로 변환해야 한다.

## 복잡도

- 시간: O(N × R × C)
- 공간: O(R × C)

*시뮬레이션 문제에서 클러스터 분리와 중력 처리를 정확히 구현하는 것이 관건이다.*

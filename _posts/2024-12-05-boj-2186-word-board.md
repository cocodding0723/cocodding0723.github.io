---
title: "BOJ 2186 — 문자판 (C++ 풀이)"
description: "DFS에 메모이제이션을 결합하여 문자판에서 단어 경로 수를 구하는 풀이. 방문 체크 없이 DP로 중복 계산을 제거한다."
date: 2024-12-05
categories: [Algorithm]
tags: [Algorithm, DFS, DP]
---

## 문제

[BOJ 2186 - 문자판](https://www.acmicpc.net/problem/2186)

N×M 문자판에서 상하좌우로 1~K칸 이동하여 주어진 단어를 만들 수 있는 경로의 수를 구하는 문제다.

## 핵심 아이디어

1. 단순 DFS는 시간 초과가 발생한다 — 같은 (위치, 깊이) 상태를 반복 탐색하기 때문이다.
2. `dp[d][x][y]` = 위치 (x,y)에서 시작하여 단어의 d번째 이후를 완성할 수 있는 경로 수.
3. **방문 체크를 하지 않는다** — 같은 칸을 다시 방문하는 것이 허용되기 때문이다.
4. `memset(dp, -1, ...)`로 초기화하여 미방문과 경로 수 0을 구분한다.

## 풀이

```cpp
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

int n, m, k;
char tiles[101][101];
int dp[81][101][101];
string str;

int dirX[4] = {1, 0, -1, 0};
int dirY[4] = {0, 1, 0, -1};

int dfs(int x, int y, int d) {
    if (dp[d][x][y] != -1) return dp[d][x][y];
    if (d + 1 == str.size()) return 1;

    int ret = 0;

    for (int i = 0; i < 4; i++) {
        for (int j = 1; j <= k; j++) {
            int nx = x + dirX[i] * j;
            int ny = y + dirY[i] * j;

            if (nx >= n || ny >= m || nx < 0 || ny < 0) continue;
            if (tiles[nx][ny] != str[d + 1]) continue;

            ret += dfs(nx, ny, d + 1);
        }
    }

    dp[d][x][y] = ret;
    return ret;
}

int main() {
    cin >> n >> m >> k;

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> tiles[i][j];

    cin >> str;

    memset(dp, -1, sizeof(dp));

    int ret = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (tiles[i][j] == str[0]) {
                ret += dfs(i, j, 0);
            }
        }
    }

    cout << ret << endl;

    return 0;
}
```

## 주요 포인트

- `dp` 초기값을 `-1`로 설정하여 "아직 계산 안 함"과 "경로 수 0"을 구분한다.
- 이동 거리가 1~K칸이므로 내부 루프에서 `j = 1 ~ k`까지 탐색한다.
- 방문 체크가 없어서 같은 칸을 여러 번 지날 수 있다 — 문제 조건에 맞는 처리다.

## 복잡도

- 시간: O(N × M × L × K) — L: 단어 길이, K: 최대 이동 거리
- 공간: O(L × N × M)

*DFS + 메모이제이션(Top-down DP)의 전형적인 패턴, 상태 정의가 핵심이다.*

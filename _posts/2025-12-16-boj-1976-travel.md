---
title: "BOJ 1976 — 여행 가자 (C++ 풀이)"
description: "Union-Find로 도시 간 연결 여부를 판별하여 여행 계획의 가능성을 확인하는 풀이."
date: 2025-12-16
categories: [Algorithm]
tags: [Algorithm]
---

## 문제

[BOJ 1976 - 여행 가자](https://www.acmicpc.net/problem/1976)

N개의 도시와 연결 정보가 주어지고, 여행 계획에 포함된 도시들이 모두 연결되어 있는지 판별하는 문제다.

## 핵심 아이디어

1. 도시 간 직접 이동뿐 아니라 다른 도시를 경유한 이동도 가능하다.
2. 따라서 **같은 연결 요소(컴포넌트)에 속하는지**만 확인하면 된다.
3. **Union-Find**로 연결된 도시들을 합치고, 여행 계획의 연속된 도시 쌍이 같은 집합인지 확인한다.

## 풀이

```cpp
#include <iostream>

using namespace std;

int cityCount, planCityCount, isLinked;
int parents[201];

int find_parent(int x) {
    if (parents[x] == x) return x;
    return parents[x] = find_parent(parents[x]);
}

void set_union(int a, int b) {
    a = find_parent(a);
    b = find_parent(b);
    if (a > b) parents[a] = b;
    else parents[b] = a;
}

bool is_union(int a, int b) {
    return find_parent(a) == find_parent(b);
}

int main() {
    for (int i = 0; i < 201; i++) parents[i] = i;

    cin >> cityCount >> planCityCount;

    for (int i = 1; i <= cityCount; i++) {
        for (int j = 1; j <= cityCount; j++) {
            cin >> isLinked;
            if (isLinked) set_union(i, j);
        }
    }

    int connectionCount = 1;
    int prevCity, currentCity;

    cin >> prevCity;

    for (int i = 1; i < planCityCount; i++) {
        cin >> currentCity;
        if (is_union(prevCity, currentCity)) {
            connectionCount++;
            prevCity = currentCity;
        }
    }

    cout << (connectionCount == planCityCount ? "YES" : "NO");

    return 0;
}
```

## 주요 포인트

- 인접 행렬로 연결 정보가 주어지므로 `isLinked == 1`이면 `set_union`으로 합친다.
- 여행 계획의 연속된 도시 쌍만 확인하면 충분하다 — 같은 컴포넌트 내에서는 어떤 경로든 이동 가능하기 때문이다.
- 경로 압축(`parents[x] = find_parent(parents[x])`)으로 효율을 확보한다.

## 복잡도

- 시간: O(N^2 × α(N)) — 인접 행렬 순회 + Union 연산
- 공간: O(N)

*Union-Find의 실전 응용, "연결되어 있는가?"라는 질문을 효율적으로 답하는 문제다.*
